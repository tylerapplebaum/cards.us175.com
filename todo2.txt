"Since your cookies are `HttpOnly` and `Secure` (which is the right security practice), JavaScript cannot access them directly. Here are your best options:

## Best Solution: Create an Authentication Check Endpoint

Have your Lambda@Edge (or API Gateway) provide a lightweight endpoint that validates the session:

```javascript
document.addEventListener(\"DOMContentLoaded\", async function () {
  if (await isUserAuthenticated()) {
    fetchSets();
    fetchSubsets();
    fetchPlayers();
    fetchBoxes();
  }
  // If not authenticated, Lambda@Edge will redirect
});

async function isUserAuthenticated() {
  try {
    // This endpoint checks the HttpOnly cookies server-side
    const response = await fetch('/api/auth/check', {
      method: 'GET',
      credentials: 'include' // Important: includes cookies in request
    });
    
    return response.ok; // 200 = authenticated, 401/403 = not authenticated
  } catch (error) {
    console.error('Auth check failed:', error);
    return false;
  }
}
```

**Lambda@Edge function** for `/api/auth/check`:
```javascript
// Simplified example - validates cookies and returns status
exports.handler = async (event) => {
  const cookies = event.Records[0].cf.request.headers.cookie;
  
  // Check if idToken cookie exists and is valid
  if (isValidCognitoToken(cookies)) {
    return {
      status: '200',
      body: JSON.stringify({ authenticated: true })
    };
  }
  
  return {
    status: '401',
    body: JSON.stringify({ authenticated: false })
  };
};
```

## Alternative Solution: Lambda@Edge Injects Authentication Flag

Have Lambda@Edge inject a meta tag or JavaScript variable when serving the HTML:

**In your Lambda@Edge Origin Response function:**
```javascript
exports.handler = async (event) => {
  const request = event.Records[0].cf.request;
  const response = event.Records[0].cf.response;
  
  // Check if user is authenticated
  const isAuthenticated = validateCognitoTokens(request.headers.cookie);
  
  if (response.status === '200' && response.headers['content-type'][0].value.includes('text/html')) {
    let body = response.body;
    
    // Inject authentication status into HTML
    const authScript = `<script>window.isAuthenticated = ${isAuthenticated};</script>`;
    body = body.replace('</head>', `${authScript}</head>`);
    
    response.body = body;
  }
  
  return response;
};
```

**In your client-side JavaScript:**
```javascript
document.addEventListener(\"DOMContentLoaded\", function () {
  // Check the injected flag
  if (window.isAuthenticated === true) {
    fetchSets();
    fetchSubsets();
    fetchPlayers();
    fetchBoxes();
  }
  // Otherwise, do nothing and let Lambda@Edge redirect
});
```

## Simplest Solution: Graceful Degradation

Just let the API calls fail gracefully and handle the 401 response:

```javascript
document.addEventListener(\"DOMContentLoaded\", function () {
  // Always try to load, but handle auth failures gracefully
  initializeApp();
});

async function initializeApp() {
  try {
    await Promise.all([
      fetchSets(),
      fetchSubsets(),
      fetchPlayers(),
      fetchBoxes()
    ]);
  } catch (error) {
    // If any call returns 401, user isn't authenticated
    if (error.status === 401 || error.status === 403) {
      console.log('Not authenticated, waiting for redirect...');
      // Lambda@Edge will handle the redirect
      return;
    }
    console.error('Error loading data:', error);
  }
}

// Update your fetch functions to throw on auth errors
async function fetchSets() {
  const response = await fetch('/api/sets', {
    credentials: 'include' // Include HttpOnly cookies
  });
  
  if (!response.ok) {
    const error = new Error('Failed to fetch sets');
    error.status = response.status;
    throw error;
  }
  
  const data = await response.json();
  // Process data...
}
```

## Recommended Approach

I'd recommend **Option 1 (Auth Check Endpoint)** because:
- ✅ Clean separation of concerns
- ✅ Fast (lightweight endpoint)
- ✅ No HTML manipulation needed
- ✅ Works with HttpOnly cookies
- ✅ Can be cached at edge

**Implementation:**

```javascript
document.addEventListener(\"DOMContentLoaded\", async function () {
  // Quick auth check before loading data
  const authenticated = await checkAuth();
  
  if (authenticated) {
    fetchSets();
    fetchSubsets();
    fetchPlayers();
    fetchBoxes();
  }
});

async function checkAuth() {
  try {
    const response = await fetch('/api/auth/check', {
      credentials: 'include',
      cache: 'no-store'
    });
    return response.ok;
  } catch {
    return false;
  }
}
```

This prevents the partial loading issue while maintaining security with HttpOnly cookies. Would you like help implementing the Lambda@Edge auth check endpoint?"
